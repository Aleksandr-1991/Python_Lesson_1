print(5,3, 'chlen', 8.5, "8.5")

n =73
print(n)
print(type(n))

n =73.8
print(n)
print(type(n))
n='Заменил"!" '
print(n)
print(type(n))
'''
n="Теерь двойные. \"Обратный слэш пред кавычкой выв её на экран без ошибки как строку.\""
print(n)
print(type(n))
'''


quality=5
equally2=5.89
c='Hello!'

print(quality,'-',equally2,'-',c)
print(f'{quality} - {equally2} - {c}')
print('{} - {} - {}'.format(quality,equally2,c)) # Три формы записи кода для выв. одного и того ж текста.

n=-0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
print(n)
print(type(n))
n=bool(n)
print(n)
print(type(n))

equally1 = float(input('Введите дробное число (желательно с длинной дробной частью): '))
equally2 = float(input('Введите дробное число (желательно с длинной дробной частью): '))
print(f'{equally1} + {equally2} = {round(equally1+equally2, 2)}')

iter = 3
iter += 5 # iter = iter + 5
iter -= 5 # iter = iter - 5
iter *= 5 # iter = iter * 5
iter /= 5 # iter = iter / 5
iter //= 5 # iter = iter // 5  - целочисленное деление.
iter %= 5 # iter = iter % 5    - остаток от деления.
iter **= 5 # iter = iter ** 5  - возведение в степень.

text1 = 'qwe'
text2 = 'qwe'
print(text1 == text2)

quality = 1 < 3 < 2 < 77
print(quality)

username = input('Введите ваше имя: ')

if username == 'Маша':
    print('Отстань уже, Маша.')
elif username == 'Ильнар':
    print('Ильнар оффигенен!')
elif username == 'Рыжик' or username == 'Лена':
    print('Неужели это Рыжик? Ураа!))')
else:
    print('Здравствуйте, ', username, '.')
    
n = int(input('Введите число для нахождения ему делителя: '))
flag = True
i = 2
while flag:
    if n % i == 0:   # т.е. ес мы нашли какой-то делитель.
        flag = False
        print(i)
    elif i > n//2:    # делитель числа не может превышать половину введённого числа.
        print(n)      # по сути данный elif обрабатывает только случаи с 1 и тройкой.
        flag = False  # для отрицательных нечётных б-выв само число (т.к. ныряет в elif и вып его усл.)
    i += 1            # для отрицательных   чётных б-выв 2 т.к. они дей-но делятся на 2.
else:
    print('Выводится ес цикл зкончил свою работу самостоятельно. Не по брейку.')
    
# for i in enumeration:
    # operator 1
    # operator 2
    # ...
    # operator n
    
for i in 1, -6, 7, 14, 5:
    print(i, end=', ')
print()

name = 'Лена'
print(name[2]) # Символ под индексом 2 это 'н'.

r = range(1, 15, 2)     # 1 3 5 7 9 11 13.  Первый арг: нач-позиция. Втор-арг: конечная позиция (исключительно). Трет-арг: Шаг.
for i in r:             # f-ция range генерирует послед-ть. Шаг всегда по умол = 1.  Нач-позиция по умол = 0.
    print(i, end=', ')  # Вместо r в цикле for м-было сразу написать range.
print()

for i in 'Прелюдия.':
    print(i, end='')   # Второй аргумент , end=''  для вывода каж-элемента не ч/з перенос строки, а ч/з указан-символы.
print()


line = ''
for i in range(5):   # 5 раз выведет по...
    line = ""
    for j in range(5):  # ... по 5 звёздочек.   Т.е. по строке с пятью звёздочками.
        line += "*"
    print (line)
    
text = 'СъЕШЬ ещё этих МяГкИх французских булок.'
print(len(text))     # Выв длину строки / массива / и люб-др-коллекции данных.
print('ещё' in text) # Она проверяет есть ли 'ещё' в строке text?
print(text.lower())  # Она приводит все буквы в нижний регистр.
print(text.upper())  # Она наоборот - в верхний.
print(text.replace('ещё', 'ЕЩЁ')) # Меняет сочетание символов в строке.  1-арг: какое сочет. нуж заменить. 2-арг: На какое сочет.
print(text[-5])      # Индексация с конца.   (послед-элемент с индексом -1).
print(text[2:10])    # Элементы от индекса 2 до 10.  (10 исключительно, правая граница как и в методе Next - исключительно).
print(text[2:])      # Элементы от индекса 2 до конца.
print(text[:10])     # Элементы от начала до индекса 10 (иск).
print(text[0:len(text):6])    # 1-арг: нач-позиция.  2-арг: конеч-позиция.  3-арг: Шаг.
print(text[::6])     # Записи идентичны. Т.к. по умол: первые два арг.. равны нулю и послед-элементу строки (коллекции).